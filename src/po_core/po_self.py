"""Po_self: Philosophical Ensemble Module.

The Po_self engine provides a deterministic yet pluggable framework for
simulating philosophical ensembles. It mirrors the public structure of
``run_ensemble`` while enriching the data model so downstream SDKs can reason
about individual philosophers, prompts, and reasoning steps.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Callable, Dict, Iterable, List, Optional, Sequence

import click
from rich.console import Console

console = Console()


@dataclass(frozen=True)
class PhilosopherProfile:
    """Metadata for a philosopher participating in the ensemble.

    Attributes:
        name: Canonical identifier used across the codebase.
        school: Philosophical tradition that contextualizes the response.
        weight: Relative influence in the ensemble aggregation step. Values are
            deterministic and kept small to avoid floating-point surprises.
        role: Short description of the philosopher's analytical lens.
    """

    name: str
    school: str
    weight: float
    role: str


@dataclass(frozen=True)
class PromptSpec:
    """Structured prompt passed into the ensemble.

    Attributes:
        text: The human-authored prompt.
        theme: Optional thematic hint used by strategies to contextualize
            responses.
        tags: Arbitrary labels (e.g., "ethics", "logic") that downstream tools
            might filter on.
    """

    text: str
    theme: Optional[str] = None
    tags: Sequence[str] = field(default_factory=tuple)


@dataclass(frozen=True)
class ReasoningStep:
    """A deterministic reasoning artifact generated by a philosopher.

    Attributes:
        philosopher: The philosopher contributing this step.
        statement: A concise synthesis responding to the prompt.
        confidence: Local confidence for this reasoning step. Downstream code
            can combine this with ``philosopher.weight``.
        rationale: Extra commentary that explains *why* the philosopher reached
            this conclusion.
    """

    philosopher: PhilosopherProfile
    statement: str
    confidence: float
    rationale: str


@dataclass(frozen=True)
class EnsembleResult:
    """Structured return type that parallels :func:`run_ensemble`.

    Attributes:
        prompt: The original ``PromptSpec``.
        steps: Ordered reasoning steps generated by each philosopher.
        aggregated_summary: High-level synthesis derived from ``steps``.
        log: Event log suitable for audit trails and CLI debugging.
    """

    prompt: PromptSpec
    steps: Sequence[ReasoningStep]
    aggregated_summary: str
    log: Dict[str, object]

    def to_response(self) -> Dict[str, object]:
        """Convert the ensemble result into a public response dict.

        The shape mirrors :func:`po_core.ensemble.run_ensemble` so callers can
        swap between deterministic prototypes without changing their code.
        """

        return {
            "prompt": self.prompt.text,
            "philosophers": [step.philosopher.name for step in self.steps],
            "results": [
                {
                    "name": step.philosopher.name,
                    "confidence": round(step.confidence, 2),
                    "summary": step.statement,
                    "tags": list(self.prompt.tags) or [step.philosopher.school],
                }
                for step in self.steps
            ],
            "log": self.log,
        }


def _default_inference(prompt: PromptSpec, philosophers: Iterable[PhilosopherProfile]) -> List[ReasoningStep]:
    """Generate deterministic reasoning steps.

    The logic intentionally avoids randomness. Each philosopher's confidence is
    scaled by their ``weight`` so future strategies can plug in probabilistic
    models without changing the public contract.
    """

    steps: List[ReasoningStep] = []
    for index, profile in enumerate(philosophers):
        adjusted_confidence = max(0.0, min(1.0, 0.85 - 0.07 * index + profile.weight))
        steps.append(
            ReasoningStep(
                philosopher=profile,
                statement=f"{profile.name.title()} contemplates '{prompt.text}' through {profile.role}.",
                confidence=adjusted_confidence,
                rationale=(
                    "Deterministic synthesis combining profile weight with prompt tags "
                    f"{', '.join(prompt.tags) if prompt.tags else 'none'}"
                ),
            )
        )
    return steps


class PoSelfEngine:
    """Deterministic ensemble executor with pluggable strategies."""

    def __init__(
        self,
        *,
        philosophers: Optional[Sequence[PhilosopherProfile]] = None,
        inference_strategy: Optional[Callable[[PromptSpec, Iterable[PhilosopherProfile]], List[ReasoningStep]]] = None,
    ) -> None:
        self.philosophers: Sequence[PhilosopherProfile] = philosophers or (
            PhilosopherProfile("aristotle", "peripatetic", 0.15, "teleological analysis"),
            PhilosopherProfile("nietzsche", "existential", 0.12, "genealogical critique"),
            PhilosopherProfile("wittgenstein", "analytic", 0.1, "language games"),
        )
        self.inference_strategy = inference_strategy or _default_inference

    def run(self, prompt: PromptSpec) -> EnsembleResult:
        """Execute the ensemble and return a structured result.

        The default strategy is deterministic, making this function safe for
        CLI demos and unit tests. Custom strategies can be supplied when the
        engine is instantiated to integrate real model calls.
        """

        steps = self.inference_strategy(prompt, self.philosophers)
        log = {
            "prompt": prompt.text,
            "philosophers": [p.name for p in self.philosophers],
            "created_at": datetime.utcnow().isoformat() + "Z",
            "events": [
                {"event": "po_self_started", "philosophers": len(self.philosophers)},
                {"event": "po_self_completed", "steps": len(steps), "status": "ok"},
            ],
        }
        aggregated_summary = " ".join(step.statement for step in steps)
        return EnsembleResult(prompt=prompt, steps=steps, aggregated_summary=aggregated_summary, log=log)


def run_po_self(prompt_text: str, *, theme: Optional[str] = None, tags: Optional[Iterable[str]] = None) -> Dict[str, object]:
    """Public helper that mirrors :func:`run_ensemble` while using Po_self.

    Args:
        prompt_text: Human-authored text to analyze.
        theme: Optional thematic label (e.g., "ethics") used to annotate the
            response and guide strategies.
        tags: Additional tags stored on the prompt; defaults to an empty tuple.

    Returns:
        A dictionary containing ``prompt``, ``philosophers``, ``results``, and
        ``log`` keys, identical to :func:`po_core.ensemble.run_ensemble` but
        enriched by deterministic reasoning steps.
    """

    prompt = PromptSpec(text=prompt_text, theme=theme, tags=tuple(tags or ()))
    engine = PoSelfEngine()
    result = engine.run(prompt)
    return result.to_response()


@click.command()
@click.argument("prompt", required=False)
def cli(prompt: Optional[str] = None) -> None:
    """Po_self CLI entry point.

    Running the command without a prompt uses a sample question to demonstrate
    the deterministic ensemble output. The payload is intentionally compact so
    SDK adopters can inspect the shape in a terminal.
    """

    console.print("[bold magenta]ðŸ§  Po_self - Philosophical Ensemble[/bold magenta]")
    selected_prompt = prompt or "What is the role of uncertainty in human growth?"
    console.print(f"[cyan]Prompt:[/cyan] {selected_prompt}\n")

    response = run_po_self(selected_prompt, tags=("po_self", "demo"))
    console.print(response)


if __name__ == "__main__":
    cli()
