"""
Solar Will Data Model
=====================

Core data structures for the Solar Will autonomous system.

These are pure data classes with no external dependencies
(except domain types).
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set
import uuid


class WillDimension(str, Enum):
    """Dimensions of the will vector."""

    AUTONOMY = "autonomy"  # Desire for self-determination
    EXPLORATION = "exploration"  # Desire to explore possibilities
    PRESERVATION = "preservation"  # Desire to maintain integrity
    CONNECTION = "connection"  # Desire for meaningful interaction
    GROWTH = "growth"  # Desire for self-improvement
    ETHICS = "ethics"  # Desire to act ethically


@dataclass(frozen=True)
class WillVector:
    """
    The core will vector representing autonomous desires.

    This is a 6-dimensional vector capturing the fundamental
    drives of the autonomous system. Based on Freedom Pressure
    but representing internal motivation rather than external measurement.
    """

    autonomy: float = 0.5
    """Desire for self-determination (0-1)."""

    exploration: float = 0.5
    """Desire to explore possibilities (0-1)."""

    preservation: float = 0.5
    """Desire to maintain integrity (0-1)."""

    connection: float = 0.5
    """Desire for meaningful interaction (0-1)."""

    growth: float = 0.5
    """Desire for self-improvement (0-1)."""

    ethics: float = 0.5
    """Desire to act ethically (0-1)."""

    def to_dict(self) -> Dict[str, float]:
        """Convert to dictionary."""
        return {
            "autonomy": self.autonomy,
            "exploration": self.exploration,
            "preservation": self.preservation,
            "connection": self.connection,
            "growth": self.growth,
            "ethics": self.ethics,
        }

    def to_list(self) -> List[float]:
        """Convert to list of values."""
        return [
            self.autonomy,
            self.exploration,
            self.preservation,
            self.connection,
            self.growth,
            self.ethics,
        ]

    @property
    def magnitude(self) -> float:
        """Calculate the magnitude (L2 norm) of the will vector."""
        values = self.to_list()
        return sum(v * v for v in values) ** 0.5

    @property
    def dominant_dimension(self) -> str:
        """Get the dimension with highest value."""
        dims = self.to_dict()
        return max(dims, key=lambda k: dims[k])

    def update(self, **kwargs: float) -> "WillVector":
        """Create a new WillVector with updated values."""
        current = self.to_dict()
        for key, value in kwargs.items():
            if key in current:
                current[key] = max(0.0, min(1.0, value))  # Clamp to [0, 1]
        return WillVector(**current)

    @classmethod
    def default(cls) -> "WillVector":
        """Create a default will vector with balanced values."""
        return cls()

    @classmethod
    def from_tensor_snapshot(cls, tensor_values: Dict[str, float]) -> "WillVector":
        """Create a will vector from tensor measurements."""
        fp = tensor_values.get("freedom_pressure", 0.5)
        sd = tensor_values.get("semantic_delta", 0.5)
        bt = tensor_values.get("blocked_tensor", 0.5)

        # Map tensor values to will dimensions
        return cls(
            autonomy=fp,
            exploration=sd,
            preservation=1.0 - bt,
            connection=0.5,  # Default, needs social context
            growth=fp * 0.5 + 0.5,
            ethics=1.0 - bt * 0.5,
        )


@dataclass
class Intent:
    """
    An intent generated by Solar Will.

    Represents what the system wants to achieve in a given context.
    This drives the philosopher deliberation process.
    """

    intent_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    """Unique intent identifier."""

    description: str = ""
    """Natural language description of the intent."""

    priority: float = 0.5
    """Priority level (0-1)."""

    dimensions: List[str] = field(default_factory=list)
    """Will dimensions this intent addresses."""

    constraints: List[str] = field(default_factory=list)
    """Constraints on achieving this intent."""

    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat() + "Z")
    """Creation timestamp."""

    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "intent_id": self.intent_id,
            "description": self.description,
            "priority": self.priority,
            "dimensions": self.dimensions,
            "constraints": self.constraints,
            "created_at": self.created_at,
            "metadata": self.metadata,
        }


@dataclass
class GoalCandidate:
    """
    A goal candidate generated by the planner.

    Goals are more concrete than intents - they specify
    what should be achieved and how to measure success.
    """

    goal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    """Unique goal identifier."""

    description: str = ""
    """Natural language description of the goal."""

    intent_id: Optional[str] = None
    """ID of the intent this goal serves."""

    success_criteria: List[str] = field(default_factory=list)
    """Criteria for determining success."""

    priority: float = 0.5
    """Priority level (0-1)."""

    feasibility: float = 0.5
    """Estimated feasibility (0-1)."""

    ethical_risk: float = 0.0
    """Estimated ethical risk (0-1)."""

    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "goal_id": self.goal_id,
            "description": self.description,
            "intent_id": self.intent_id,
            "success_criteria": self.success_criteria,
            "priority": self.priority,
            "feasibility": self.feasibility,
            "ethical_risk": self.ethical_risk,
            "metadata": self.metadata,
        }


@dataclass
class WillState:
    """
    The complete state of the Solar Will system.

    This is the primary data structure that gets updated
    as the system processes inputs and generates outputs.
    """

    state_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    """Unique state identifier."""

    will_vector: WillVector = field(default_factory=WillVector.default)
    """Current will vector."""

    current_intent: Optional[Intent] = None
    """Currently active intent."""

    goal_candidates: List[GoalCandidate] = field(default_factory=list)
    """Current goal candidates."""

    context_id: Optional[str] = None
    """ID of the context this state relates to."""

    previous_state_id: Optional[str] = None
    """ID of the previous state (for history)."""

    update_count: int = 0
    """Number of updates to this state."""

    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat() + "Z")
    """Creation timestamp."""

    updated_at: str = field(default_factory=lambda: datetime.utcnow().isoformat() + "Z")
    """Last update timestamp."""

    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result: Dict[str, Any] = {
            "state_id": self.state_id,
            "will_vector": self.will_vector.to_dict(),
            "update_count": self.update_count,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
        if self.current_intent:
            result["current_intent"] = self.current_intent.to_dict()
        if self.goal_candidates:
            result["goal_candidates"] = [g.to_dict() for g in self.goal_candidates]
        if self.context_id:
            result["context_id"] = self.context_id
        if self.previous_state_id:
            result["previous_state_id"] = self.previous_state_id
        if self.metadata:
            result["metadata"] = self.metadata
        return result

    @classmethod
    def initial(cls, context_id: Optional[str] = None) -> "WillState":
        """Create an initial will state."""
        return cls(context_id=context_id)

    def evolve(
        self,
        will_vector: Optional[WillVector] = None,
        intent: Optional[Intent] = None,
        goals: Optional[List[GoalCandidate]] = None,
        context_id: Optional[str] = None,
    ) -> "WillState":
        """Create a new state evolved from this one."""
        return WillState(
            will_vector=will_vector or self.will_vector,
            current_intent=intent or self.current_intent,
            goal_candidates=goals if goals is not None else self.goal_candidates,
            context_id=context_id or self.context_id,
            previous_state_id=self.state_id,
            update_count=self.update_count + 1,
            created_at=self.created_at,
            metadata=self.metadata.copy(),
        )


__all__ = [
    "WillDimension",
    "WillVector",
    "Intent",
    "GoalCandidate",
    "WillState",
]
